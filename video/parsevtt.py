import requests
import os

import re
import json

def main():
    FILE_DUMP = "TEMP_SAVE_FOLDER"
    os.makedirs(FILE_DUMP, exist_ok=True)

    file_path = f"{FILE_DUMP}/video.en.vtt"

    cues = parse_vtt(file_path)

    # If video is autogenerated, we need to remove duplicates
    groups = merge_cues(cues)

    #print_cues(groups)
    json_output = export_to_json(groups, f"{FILE_DUMP}/video.json")

def parse_vtt(file_path):
    """
    Parse a VTT file and return a list of cue dictionaries with start time, end time, and text.
    """
    cues = []
    timestamp_pattern = re.compile(r'^(\d{2}:\d{2}:\d{2}\.\d{3})\s+-->\s+(\d{2}:\d{2}:\d{2}\.\d{3})')
    
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.read().splitlines()

    current_cue = None
    text_lines = []

    for line in lines:
        # Check if the line is a cue header with timestamps.
        match = timestamp_pattern.match(line)
        if match:
            # Save the previous cue if it exists.
            if current_cue is not None:
                # Join text lines and remove inline cues
                text = " ".join(text_lines)
                text = re.sub(r'<[^>]+>', '', text)  # Remove inline timestamps and HTML-like tags
                text = re.sub(r'\s+', ' ', text).strip()
                cues.append({
                    'start': current_cue['start'],
                    'end': current_cue['end'],
                    'text': text
                })

            # Start a new cue.
            current_cue = {'start': match.group(1), 'end': match.group(2)}
            text_lines = []
        elif line.strip() == "":
            # Blank lines can indicate the end of a cue block.
            continue
        else:
            # Accumulate text lines.
            text_lines.append(line.strip())

    # Save any remaining cue at the end of the file.
    if current_cue is not None and text_lines:
        text = " ".join(text_lines)
        text = re.sub(r'<[^>]+>', '', text)
        text = re.sub(r'\s+', ' ', text).strip()
        cues.append({
            'start': current_cue['start'],
            'end': current_cue['end'],
            'text': text
        })

    return cues

def merge_cues(cues):
    """
    Merge consecutive cues if the text appears to be repeating.
    
    If a cue's text ends with the text of the following cue,
    we treat them as a group. The merged group takes the start time
    from the first cue and the end time from the last cue in the group,
    and uses the text of the last cue (i.e. the "new" part).
    
    This handles groups of 2 or more repeated cues.
    """
    merged = []
    i = 0
    while i < len(cues):
        # Start a group with the current cue.
        group_start = cues[i]['start']
        group_end = cues[i]['end']
        group_text = cues[i]['text']
        j = i + 1
        
        # Extend the group if subsequent cues are "repetitions"
        # i.e. if the previous cue's text ends with the next cue's text.
        while j < len(cues) and cues[j-1]['text'].endswith(cues[j]['text']):
            group_end = cues[j]['end']
            group_text = cues[j]['text']
            j += 1
        
        merged.append({
            'start': group_start,
            'end': group_end,
            'text': group_text
        })
        i = j  # Move to the next ungrouped cue
    return merged

def print_cues(cues):
    """
    Print cues in a human-readable format.
    """
    for cue in cues:
        print(f"{cue['start']} --> {cue['end']}")
        print(cue['text'])
        print("-" * 40)

def export_to_json(groups, output_path=None):
    """
    Export the list of merged groups to a JSON formatted string.
    If output_path is provided, also write the JSON to that file.
    """
    data = {"captions": groups}
    json_str = json.dumps(data, indent=4)
    
    if output_path:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(json_str)
    
    return json_str

if __name__ == '__main__':
    main()
